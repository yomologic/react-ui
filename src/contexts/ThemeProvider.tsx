"use client";

import {
    createContext,
    useContext,
    ReactNode,
    useState,
    useEffect,
} from "react";
import themes from "../themes";

interface Theme {
    name: string;
    id: string;
    colors: Record<string, string>;
    components: Record<string, Record<string, string>>;
    typography?: Record<string, string>;
    showcase?: Record<string, string>;
    semanticColors?: Record<string, string>;
}

interface ThemeContextType {
    currentTheme: string;
    availableThemes: { id: string; name: string }[];
    setTheme: (themeId: string) => void;
    setCSSVariable: (name: string, value: string) => void;
    getCSSVariable: (name: string) => string;
    exportThemeCSS: () => string;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

// Convert imported themes to Theme type
const themeRegistry: Record<string, Theme> = themes as Record<string, Theme>;

// Get initial theme from localStorage
const getInitialTheme = (defaultTheme: string = "dark"): string => {
    if (typeof window === "undefined") return defaultTheme;
    try {
        const saved = localStorage.getItem("yomologic-theme");
        return saved && themeRegistry[saved] ? saved : defaultTheme;
    } catch {
        return defaultTheme;
    }
};

interface ThemeProviderProps {
    children: ReactNode;
    defaultTheme?: string;
    customTheme?: Theme;
    storageKey?: string;
}

export function ThemeProvider({
    children,
    defaultTheme = "dark",
    customTheme,
    storageKey = "yomologic-theme",
}: ThemeProviderProps) {
    const [currentTheme, setCurrentTheme] = useState<string>(() =>
        getInitialTheme(defaultTheme)
    );
    const [availableThemes] = useState(
        Object.values(themeRegistry).map((t) => ({ id: t.id, name: t.name }))
    );

    const setCSSVariable = (name: string, value: string) => {
        if (typeof window === "undefined") return;
        document.documentElement.style.setProperty(name, value);
    };

    const getCSSVariable = (name: string): string => {
        if (typeof window === "undefined") return "";
        return getComputedStyle(document.documentElement)
            .getPropertyValue(name)
            .trim();
    };

    const applyTheme = (theme: Theme) => {
        // Apply color variables
        Object.entries(theme.colors).forEach(([key, value]) => {
            setCSSVariable(`--color-${key}`, value);
        });

        // Apply showcase-specific colors (if present)
        if (theme.showcase) {
            Object.entries(theme.showcase).forEach(([key, value]) => {
                setCSSVariable(`--showcase-${key}`, value);
            });
        }

        // Apply semantic colors (if present)
        if (theme.semanticColors) {
            Object.entries(theme.semanticColors).forEach(([key, value]) => {
                setCSSVariable(`--color-${key}`, value);
            });
        }

        // Apply typography variables (if present)
        if (theme.typography) {
            Object.entries(theme.typography).forEach(([key, value]) => {
                setCSSVariable(`--typography-${key}`, value);
            });
        }

        // Apply component-specific variables
        Object.entries(theme.components).forEach(([component, vars]) => {
            Object.entries(vars).forEach(([key, value]) => {
                // Convert card-icons.blue-bg to --card-icon-blue-bg
                const varName =
                    component === "card-icons"
                        ? `--card-icon-${key}`
                        : `--${component}-${key}`;
                setCSSVariable(varName, value);
            });
        });

        // Update body background and text color
        setCSSVariable("--background", theme.colors.background);
        setCSSVariable("--foreground", theme.colors.foreground);
    };

    const setTheme = (themeId: string) => {
        const theme = customTheme || themeRegistry[themeId];
        if (!theme) {
            console.error(`Theme not found: ${themeId}`);
            return;
        }

        applyTheme(theme);
        setCurrentTheme(themeId);

        // Save to localStorage
        if (typeof window !== "undefined") {
            localStorage.setItem(storageKey, themeId);
        }
    };

    const exportThemeCSS = (): string => {
        if (typeof window === "undefined") return "";

        const root = document.documentElement;
        const cssVariables: Record<string, string> = {};

        // Get all CSS custom properties from :root
        for (let i = 0; i < root.style.length; i++) {
            const propertyName = root.style[i];
            if (propertyName.startsWith("--")) {
                cssVariables[propertyName] =
                    root.style.getPropertyValue(propertyName);
            }
        }

        // Generate CSS file content
        const timestamp = new Date().toISOString().split("T")[0];
        let css = `/* Generated by @yomologic/react-ui Theme Builder */\n`;
        css += `/* Created: ${timestamp} */\n\n`;
        css += `:root {\n`;

        // Group variables by prefix for better organization
        const groups: Record<string, string[]> = {};
        Object.keys(cssVariables)
            .sort()
            .forEach((varName) => {
                const prefix = varName.split("-")[1] || "other";
                if (!groups[prefix]) groups[prefix] = [];
                groups[prefix].push(varName);
            });

        // Write grouped variables
        Object.entries(groups).forEach(([prefix, vars]) => {
            css += `  /* ${prefix.charAt(0).toUpperCase() + prefix.slice(1)} */\n`;
            vars.forEach((varName) => {
                css += `  ${varName}: ${cssVariables[varName]};\n`;
            });
            css += `\n`;
        });

        css += `}\n`;
        return css;
    };

    // Apply theme on mount
    useEffect(() => {
        const theme = customTheme || themeRegistry[currentTheme];
        if (theme) {
            applyTheme(theme);
        }
    }, [currentTheme, customTheme, applyTheme]);

    return (
        <ThemeContext.Provider
            value={{
                currentTheme,
                availableThemes,
                setTheme,
                setCSSVariable,
                getCSSVariable,
                exportThemeCSS,
            }}
        >
            {children}
        </ThemeContext.Provider>
    );
}

export function useTheme() {
    const context = useContext(ThemeContext);
    if (context === undefined) {
        throw new Error("useTheme must be used within a ThemeProvider");
    }
    return context;
}
